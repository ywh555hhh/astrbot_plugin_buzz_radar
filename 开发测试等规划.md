# BuzzRadar (喧嚣雷达) 深度优化 - 开发与测试规划

本文档旨在规划 **BuzzRadar** 从简单计数器向智能热度感知产品的演进路线。

## 1. 实现思路 (Implementation Concepts)

基于四大核心维度，我们将重构插件的架构。

### 1.1 架构设计
插件将分为以下几个核心模块：
- **ConfigManager**: 管理所有可配置参数（权重、阈值、语气模板等）。
- **MessageFilter**: 负责“信号提纯”，实现去噪、去重、指令过滤。
- **ScoreEngine**: “计分系统”，根据消息类型（长文本、引用、媒体）计算热度分。**引入 Leaky Bucket (漏桶) 或 Score Cap 机制，防止分数无限膨胀。**
- **RadarSystem**: 核心逻辑，维护滑动窗口或时序队列，计算加速度，处理“防抖”和“熔断”。**确保 Per-Group State Isolation (每群状态隔离)，避免并发竞争。**
- **PersistenceLayer**: 负责简单的状态持久化 (`last_trigger_time`, `cooldown`)，防止重启“失忆”。
- **ContentSampler**: 负责上下文采样，提取关键信息（首尾+中间高权重样本）。
- **PersonaDriver**: 表现层驱动，根据配置随机选择语气模板并生成 Prompt。

### 1.2 关键算法逻辑
- **热度衰减 & 封顶**: 
    - 设定 `MaxScore` (e.g., 1000)，超过不计。
    - 随时间线性或指数衰减。
- **加速度检测**: 
    - 维护两个计数器：`CurrentWindowScore` (当前 N 分钟) 和 `PreviousWindowScore` (上个 N 分钟)。
    - 若 `Current` > `Previous` * `VelocityThreshold` 且 `Current` > `MinTriggerScore`，则触发加速预警（降低总阈值）。

## 2. 开发与测试计划 (Development & Testing Plan)

我们将开发过程分为四个阶段（P0, P1, P1.5, P2, P3），循序渐进。

### Phase 0: 测试基础设施搭建 (Infrastructure) - ✅ Completed
- **目标**: 工欲善其事，必先利其器。
- **任务**:
    - [x] 创建 `tests/` 目录。
    - [x] 编写 `mock_event.py`: 模拟 `AstrMessageEvent` 对象。
    - [x] 编写 `scenario_runner.py`: 能够加载 JSON 日志文件，并模拟不同速率向插件发送事件。
- **交付物**: 一个可以在 1 秒内跑完 "10分钟刷屏" 场景的测试脚本。

### Phase 1: 基础架构、配置与持久化 (Core & Persistence) - ✅ Completed
- **目标**: 完成配置系统、去噪计分、状态管理与持久化。
- **任务**:
    - [x] 设计 `_conf_schema.json`，涵盖所有权重和阈值参数。
    - [x] 实现 `MessageFilter` 和 `ScoreEngine` (含 Score Cap)。
    - [x] 实现 `RadarSystem` 的基础骨架，确保 **State Isolation** (每个群一个 Instance)。
    - [x] 实现 `PersistenceLayer`: 在 `terminate` 时保存关键状态 (`last_trigger_time`) 到 `data/buzz_radar_persistence.json`。
    - [x] 改造 `main.py`：接入新的架构。
- **交付物**: 一个具有记忆功能、并发安全、不会分数爆炸的基础热度插件。

### Phase 1.5: 管理与交互 (Admin System) - 🔄 New
- **目的**: 提供插件的“控制台”能力，增强可观测性和可控性。
- **指令体系**: 使用 `/radar` 作为主指令。
    - `/radar status` (或 `/热度`): 查看当前群热度、流速、冷却状态。使用 ASCII 进度条可视化。
    - `/radar calm` (或 `/降温`): 紧急重置当前群热度，并可选进入冷却。
    - `/radar test [level]`: (超管) 模拟触发，用于调试 Prompt。
- **安全**: 严格的权限控制 (`event.get_sender_role()`)。
- **接口扩展**: `RadarSystem` 需暴露 `get_group_state()` 和 `force_reset()` 方法。

### Phase 2: 智能触发与采样 (Intelligence)
- **目标**: 让触发更像人，解决成本问题。
- **任务**:
    - [ ] 实现 `RadarSystem` 的加速度检测与防抖逻辑 (Random Delay)。
    - [ ] 实现 `ContentSampler`：智能截取话题的 Head + Tail + Random Middle。
    - [ ] 接入 LLM 调用前的熔断保护 (Circuit Breaker)。
- **交付物**: 在突发热点时能更快反应，且不会在深夜频繁打扰，Token 消耗大幅降低。

### Phase 3: 拟人化与表现层 (Persona)
- **目标**: 提升用户体验，增加趣味性。
- **任务**:
    - [ ] 扩展配置，支持“语气模板库” (Persona Matrix)。
    - [ ] 优化 Prompt，将采样后的上下文 + 语气要求 组装发给 LLM。
    - [ ] 尝试实现“点击跳转/引用”功能（视平台支持情况）。
- **交付物**: 一个像“群友”一样的智能总结 Bot。

## 3. 测试环境准备 (Test Environment Preparation)

由于涉及多人并发、刷屏等场景，单纯靠两个号手动发很难复现真实压力。我们需要搭建模拟环境。

### 准备工作
1.  **Mock 环境**:
    - 既然有 `Reference Doc` 提到 Discord-QQ Bridge，我们可以利用现有的 AstrBot 测试框架或自己写脚本。
    - **建议**: 编写一个 Python 脚本 `tests/scenario_runner.py`，可以直接调用 Plugin 的处理函数，模拟大量 `AstrMessageEvent` 的涌入。
    - 不需要真实的 QQ/微信 客户端，直接 Mock 事件对象即可。

2.  **测试数据构造**:
    - 构造 `normal_chat_log.json`: 模拟日常稀疏对话（每分钟 1-2 条）。
    - 构造 `breaking_news_log.json`: 模拟突发新闻（前 5 分钟沉默，第 6 分钟突然 50 条/分）。
    - 构造 `spam_log.json`: 模拟复读机刷屏（100 条完全一样的表情包）。

## 4. 测试计划 (Test Plan)

### 4.1 单元测试 (Unit Tests)
- **Filter Test**: 喂入 10 条 "666"，预期计分应显著低于 10 分（去重生效）。喂入 "/help"，预期不计分。
- **Sampler Test**: 喂入 100 条消息列表，检查输出是否保留了第 1-5 条和第 90-100 条，总长度是否在 Token 限制内。

### 4.2 场景模拟测试 (Simulation Check)
- **核心原则**: **Precision > Recall** (宁可漏报，不可误报)。
- **场景 A：深夜防打扰与防误报**
    - 运行 `spam_log.json` (大量复读机表情包)。
    - **预期**: Score 应该被 Cap 住或由 Filter 过滤，**不应触发**任何主动消息。
- **场景 B：并发压力测试**
    - 启动脚本模拟 50 个群同时进消息。
    - **预期**: 每个群的 Score 独立计算，互不干扰。内存占用稳定。
- **场景 C：突发吃瓜 (True Positive)**
    - 运行 `breaking_news_log.json`。
    - **预期**: 在流量爆发的第 1-2 分钟内触发总结。

### 4.3 真实环境验收 (Staging)
- **步骤**:
    - 部署到测试群。
    - 观察一整天，收集日志。
    - **重点关注**: 误报率 (False Positive Rate)。如果发现Bot在无关紧要的时候插嘴，立即调高阈值或优化 Filter。
